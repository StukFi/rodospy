# -*- coding: utf-8 -*-
from owslib.wps import WebProcessingService
import osr
import ogr
import os
from datetime import datetime, timedelta
from urllib.request import Request
from urllib.request import urlopen
import json
import codecs
import tempfile
import zipfile
from dateutil.parser import parse
from xml.etree.ElementTree import XML, fromstring, tostring
from pathlib import Path
# standard logging
import logging
logger = logging.getLogger('rodospy')
# set to INFO or WARNING in production environment
# set logging format
FORMAT = '%(asctime)-15s %(levelname)-6s %(message)s'
formatter = logging.Formatter(fmt=FORMAT)
# output to console
ch = logging.StreamHandler()
ch.setFormatter(formatter)
logger.addHandler(ch)

# URL fetching parameters
reader = codecs.getreader("utf-8")
xml_headers = { 'Content-Type': 'application/xml' }

# Add formatting and handlers as needed
owslib_log = logging.getLogger('owslib')
owslib_log.setLevel(logging.DEBUG)

# GDAL constants
wgs84_cs = osr.SpatialReference()
wgs84_cs.ImportFromEPSG(4326)
gml_driver = ogr.GetDriverByName('GML')
gpkg_driver = ogr.GetDriverByName('GPKG')

def datetime_parser(value):
    "datetime parser for json document"
    if isinstance(value, dict):
        for k, v in value.items():
            value[k] = datetime_parser(v)
    elif isinstance(value, list):
        for index, row in enumerate(value):
            value[index] = datetime_parser(row)
    elif isinstance(value, str) and value:
        try:
            value = parse(value)
        except (ValueError, AttributeError):
            pass
    return value

def from_rodos_nuclide(nuclide):
    "rodos nuclide has fixed string lenght"
    n = nuclide.split("-")
    n[0] = n[0].strip()
    n[1] = n[1].strip()
    return n[0] + "-" + n[1]

class RodosPyException(Exception):
    "Module specific exception"
    pass

class RodosConnection(object):
    """
    Setup JRodos database and Geoserver connection
    When initialized, connections are checked.
    The connection settings will be passed to other classes.
    """
    def __repr__(self):
        return ("<RodosConnection %s | %s>" % (self.wps))

    def __init__(self,settings=None):
        "Initialize RODOS DB and WPS connection"
        logger.debug("Read settings from file")
        if settings==None:
            # try to read from config file
            raise RodosPyException( "No settings defined" )
        self.w = settings["wps"]
        self.wps = WebProcessingService(self.w["url"], 
                                        verbose=False, # set this True when debugging
                                        skip_caps=True)
        self.storage = self.w["file_storage"]
        self.r = settings["rest"]
        self.rest_url = self.r["url"]
        # check that connections are OK
        self.wps_capabilities = self.wps.getcapabilities()
        self.projects = self.get_projects()

    def refresh_projects():
        "get refreshed list of projects"
        self.projects = self.get_projects()

    def get_projects(self): # fetch the project list
        """
        Get listing of projects. 
        project_uid as parameter if only one project information wanted."
        """
        # rest request
        response = urlopen( self.rest_url + "/projects" )
        proj_dict = json.load(reader(response),
                              object_hook=datetime_parser)["content"]
        # create list of project classes
        projects = []
        for p in proj_dict:
            projects.append(Project(self,p))
        return projects

class Project(object):
    """
    Create Project instance.
    project must be tuple generated by RodosConnection 
    or project uid
    """
    def __repr__(self):
        return ("<Project %s | %s>" % (self.name, self.modelchainname))

    def __init__(self,rodos,values):
        """
        Project class is created based on project id fetch from REST service
        project_id is integer
        """
        self.rodos = rodos
        for key in values:
            setattr(self,key,values[key])

    def load(self):
        """Load project metadata"""
        # request project details from rest service
        response = urlopen( self.rodos.rest_url + "/projects/{:d}".format(
            self.projectId))
        details_dict = json.load(reader(response),
                                 object_hook=datetime_parser)
        # set metadata as attributes
        for key in details_dict:
            if (key not in ("tasks","extendedProjectInfo")):
                setattr(self,key,details_dict[key])
            elif key=="extendedProjectInfo":
                for key2 in details_dict[key]:
                    setattr(self,key2,details_dict[key][key2])
        # set source term nuclides as list
        self.sourcetermNuclides = self.sourcetermNuclides.split(",")
        for t in details_dict["tasks"]:
            self.tasks.append ( Task(self,t) )

class Task(object):
    """
    JRodos Task instance. Contains single model run.
    """
    def __repr__(self):
        return ("<Task %s | %s>" % (self.modelwrappername, self.description))

    def __init__(self,project,tdict):
        self.rodos = project.rodos
        self.project = project
        self.dataitems = []
        for key in tdict:
            if key!="dataitems":
                setattr(self,key,tdict[key])
        self.dataitems_json = tdict["dataitems"] # use this for searchs?
        self.gridseries = []
        for d in tdict["dataitems"]:
            if d["dataitem_type"]=="GridSeries":
                self.gridseries.append( GridSeries(self,d) )
        self.deposition = {}
        self.wet_deposition = {}
        self.dry_deposition = {}
        self.air_concentration = {}
        self.time_integrated_air_concentration = {}
        self.total_deposition = {}
        self.ground_gamma_dose_rate = {}
        self.total_dose = {}
        self.cloud_dose = {}
        self.ground_dose = {}
        self.inhalation_dose = {}
        self.skin_dose = {}
        
        # classify grid series to dictionaries
        # TODO: some items still missing (FDMT, Emersim, DEPOM etc.)
        for i in self.gridseries:
            try:
                i.nuclide = from_rodos_nuclide(i.name)
            except IndexError: # not nuclide dependent
                i.nuclide = None
            if i.groupname=="ground.contamination":
                self.deposition[i.nuclide] = i
            elif i.groupname=="ground.contamination.wet":
                self.wet_deposition[i.nuclide] = i
            elif i.groupname=="ground.contamination.dry":
                self.wet_deposition[i.nuclide] = i
            elif i.groupname=="air.concentration.near.ground.surface":
                self.air_concentration[i.nuclide] = i
            elif i.groupname==\
                "air.concentration.time.integrated.near.ground.surface":
                self.time_integrated_air_concentration[i.nuclide] = i
            elif i.groupname=="air.concentration.instantaneous.exceeded":
                self.concentration_exceeded = i
            elif i.groupname=="Graphical_Aerosol":
                self.total_deposition["aerosol"] = i
            elif i.groupname=="Graphical_Iodine":
                self.total_deposition["iodine"] = i
            elif i.groupname=="total.gamma.dose.rate":
                self.total_gamma_dose_rate = i
            elif i.groupname=="DOSRCL":
                self.cloud_total_gamma_dose_rate = i
            elif i.groupname=="DRNUGR":
                self.ground_gamma_dose_rate[i.nuclide] = i
            elif i.groupname=="total.dose":
                self.total_dose[i.name] = i
            elif i.groupname=="cloud.dose":
                self.cloud_dose[i.name] = i
            elif i.groupname=="ground.dose":
                self.ground_dose[i.name] = i
            elif i.groupname=="inhalation.dose":
                self.inhalation_dose[i.name] = i
            elif i.groupname=="skin.dose":
                self.skin_dose[i.name] = i
            elif i.groupname=="total.dose.nuclide.specific":
                self.total_dose[i.name] = i

class GridSeries(object):
    "Series of grid results"
    def __repr__(self):
        return ("<GridSeries %s | %s>" % (self.groupname, self.name))

    def __init__(self,task,ddict):
        self.task = task
        self.project = task.project
        self.rodos = task.rodos
        self.gpkgfile = None
        for key in ddict:
            setattr(self,key,ddict[key])
        self.output_dir = "{}/{}/{}/{}".format(self.rodos.storage,
                                               self.task.project.name,
                                               self.task.project.modelchainname,
                                               self.datapath.replace(" ","_"))

    def times(self):
        "Read timestamps of data"
        gis_data = gpkg_driver.Open(self.gpkg_file())
        layer = gis_data.GetLayer(1) # data layer
        times = []
        for feature in layer:
            time_value = feature.GetField ( "Time" )
            #unique times
            if not time_value in times:
                times.append(time_value)
        times.sort()
        # convert epoch times to datetime objects
        return list(map(datetime.fromtimestamp,times))

    def levels(self):
        "TODO"
        return []

    def get_filepath(self):
        "generate filepath if check if it does exists"
        if not os.path.isdir(self.output_dir):
            self.save_gpkg()
        return self.output_dir
    
    def gpkg_file(self):
        "get full path of gpkg file"
        return self.get_filepath() + "/" + os.listdir( self.get_filepath() )[0]

    def save_gpkg(self,output_dir=None,force=True):
        "Read and save GeoPackage file from WPS service"
        if output_dir==None:
            output_dir = self.output_dir
        wps_input = [
                ('taskArg', 
                 "project='{}'&amp;model='{}'".format(self.task.project.name,\
                                                      self.task.project.modelchainname)),
                ('dataitem',
                 "path='%s'" % self.datapath),
                ('columns', "0-"), # get the whole dataset
                ('vertical', "0"), # TODO: think!
                ('includeSLD', "1"),
                ('threshold', "1e-15") # TODO: add threshold support
            ]
        x = open("request_template.xml").read()
        x = x.replace("TASKARG",wps_input[0][1])
        x = x.replace("DATAITEM",wps_input[1][1])
        x = x.replace("COLUMNS",wps_input[2][1])
        x = x.replace("THRESHOLD",wps_input[5][1])
        #wps_run = self.rodos.wps.execute('gs:JRodosGeopkgWPS',wps_input)
        req = Request ( self.rodos.w["url"],
                        data = x.encode(), 
                        headers = xml_headers)
        logger.debug ( "Execute WPS with values %s" % (str(wps_input)) )
        response = urlopen( req )
        temp = tempfile.NamedTemporaryFile() #2
        try:
            resp_file = open(temp.name, "wb")
            resp_file.write( response.read() )
            resp_file.close()
            Path(output_dir).mkdir(parents=True, exist_ok=True)
            with zipfile.ZipFile(temp.name, 'r') as zip_ref:
                zip_ref.extractall(output_dir)
        finally:
            temp.close() 
        self.filepath = output_dir
        return self.filepath

    def envelope(self):
        "Get the bbox of data"
        gis_data = gpkg_driver.Open(self.gpkg_file())
        layer = gis_data.GetLayer(0) # grid
        return layer.GetExtent()    

    def max(self,time_value=None):
        """
        Get max value and its lon/lat location
        Filter by time value is supported.
        """
        gis_data = gpkg_driver.Open(self.gpkg_file())
        layer = gis_data.GetLayer(2) # view
        if time_value!=None:
            epoch_time = int(time_value.timestamp())
            layer.SetAttributeFilter( "Time={:d}".format(epoch_time) )
        max_value = 0
        geom_wkt = None
        timestamp = None
        for feature in layer:
            value = feature.GetField("Value")
            if value>max_value:
                max_value = value
                geom_wkt = feature.GetGeometryRef().ExportToWkt()
                timestamp = feature.GetField("Time")
        if geom_wkt!=None:
            transform = osr.CoordinateTransformation(layer.GetSpatialRef(),wgs84_cs)
            polygon = ogr.CreateGeometryFromWkt(geom_wkt)
            # use point instead of polygon
            point = polygon.PointOnSurface()
            lon,lat,dummy = transform.TransformPoint(point.GetX(),point.GetY())
        else:
            lon,lat = None, None
        if max_value>0:
            timestamp = datetime.fromtimestamp(timestamp)
        return (max_value,(lon,lat),timestamp)

    def areaExceeding(self,value,time_value):
        "calculate area where value is exceeded"
        gis_data = gpkg_driver.Open(self.gpkg_file())
        layer = gis_data.GetLayer(2) # view
        if time_value!=None:
            epoch_time = int(time_value.timestamp())
            layer.SetAttributeFilter( "Time={:d}".format(epoch_time) )
        layer.SetAttributeFilter( "Value > %f" % value )
        area = 0
        for feature in layer:
            area += feature.GetGeometryRef().GetArea()
        return area

    def timeSeries(self,lon,lat):
        "extract time series in singe point"
        times = self.times
        point = ogr.Geometry(ogr.wkbPoint)
        point.AddPoint( lon,lat )
        gis_data = gpkg_driver.Open(self.gpkg_file())
        layer = gis_data.GetLayer(0) # grid
        transform = osr.CoordinateTransformation(wgs84_cs,layer.GetSpatialRef())
        point.Transform( transform )
        found = False
        for feature in layer:
            data_geom = feature.GetGeometryRef()
            if data_geom.Intersects( point ):
                cell = float(feature.GetField("Cell"))
                found = True
                break
        if not found:
            return None
        layer = gis_data.GetLayer(2) # view
        layer.SetAttributeFilter( "cell={:d}".format(int(cell)) )
        values = {}
        for feature in layer:
            value = feature.GetField("Value")
            t_value = feature.GetField("Time")
            values[t_value] = value
        # sort by time
        x = []
        y = []
        for key in sorted(values.keys()):
            x.append(key)
            y.append(values[key])
        return {"times": list(map(datetime.fromtimestamp,x)), 
                "values": y, 
                "unit": self.unit, 
                "title": "{} at point ({},{})".format(self.name,
                                                      "{0:.3f}".format(lon),
                                                      "{0:.3f}".format(lat))
                }
