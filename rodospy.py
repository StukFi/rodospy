# -*- coding: utf-8 -*-
from owslib.wps import WebProcessingService
import osr
import ogr
import os
from datetime import datetime, timedelta
from copy import copy
from urllib.request import Request
from urllib.request import urlopen
import json
import codecs
import tempfile
import base64
import zipfile
from dateutil.parser import parse
from xml.etree.ElementTree import XML, fromstring, tostring
from pathlib import Path
# standard logging
import logging
logger = logging.getLogger('rodospy')
# set to INFO or WARNING in production environment
# set logging format
FORMAT = '%(asctime)-15s %(levelname)-6s %(message)s'
formatter = logging.Formatter(fmt=FORMAT)
# output to console
ch = logging.StreamHandler()
ch.setFormatter(formatter)
logger.addHandler(ch)

# URL fetching parameters
reader = codecs.getreader("utf-8")
xml_headers = { 'Content-Type': 'application/xml' }

owslib_log = logging.getLogger('owslib')
# Add formatting and handlers as needed
owslib_log.setLevel(logging.DEBUG)

# GDAL contants
wgs84_cs = osr.SpatialReference()
wgs84_cs.ImportFromEPSG(4326)
gml_driver = ogr.GetDriverByName('GML')
gpkg_driver = ogr.GetDriverByName('GPKG')

def datetime_parser(value):
    if isinstance(value, dict):
        for k, v in value.items():
            value[k] = datetime_parser(v)
    elif isinstance(value, list):
        for index, row in enumerate(value):
            value[index] = datetime_parser(row)
    elif isinstance(value, str) and value:
        try:
            value = parse(value)
        except (ValueError, AttributeError):
            pass
    return value

def time_formatter(time_string):
    "format rodos strings to python datetime objects"
    # two possible time formats
    try:
        time_value = datetime.strptime( time_string.split(".")[0], \
            '%Y-%m-%dT%H:%M:%S')
    except ValueError:
        time_value = datetime.strptime( time_string.split(".")[0], \
            '%Y-%m-%dT%H:%M:%SZ')
    return time_value

def to_rodos_nuclide(nuclide):
    "Convert nuclide string to Rodos format inherited from 80s"
    n = nuclide.split("-")
    element = n[0]
    mass = n[1]
    nuc_string = element
    if len(element)==1:
        nuc_string += " "
    nuc_string += "-"
    if len(mass)==2:
        nuc_string += " "
    elif len(mass)==1:
        nuc_string += "  "
    nuc_string += mass
    return nuc_string

def from_rodos_nuclide(nuclide):
    n = nuclide.split("-")
    n[0] = n[0].strip()
    n[1] = n[1].strip()
    return n[0] + "-" + n[1]

class RodosPyException(Exception):
    "Module specific exception"
    pass

class RodosConnection(object):
    """
    Setup JRodos database and Geoserver connection
    When initialized, connections are checked.
    The connection settings will be passed to other classes.
    """
    def __repr__(self):
        return ("<RodosConnection %s | %s>" % (self.wps))

    def __init__(self,settings=None):
        "Initialize RODOS DB and WPS connection"
        logger.debug("Read settings from file")
        if settings==None:
            # try to read from config file
            raise RodosPyException( "No settings defined" )
        self.w = settings["wps"]
        self.wps = WebProcessingService(self.w["url"], 
                                        verbose=False, # set this True when debugging
                                        skip_caps=True)
        self.storage = self.w["file_storage"]
        self.r = settings["rest"]
        self.rest_url = self.r["url"]
        # check that connections are OK
        self.wps_capabilities = self.wps.getcapabilities()
        self.projects = self.get_projects()

    def refresh_projects():
        "get refreshed list of projects"
        self.projects = self.get_projects()

    def get_projects(self): # fetch the project list
        """
        Get listing of projects. 
        project_uid as parameter if only one project information wanted."
        """
        # rest request
        response = urlopen( self.rest_url + "/projects" )
        proj_dict = json.load(reader(response),
                              object_hook=datetime_parser)["content"]
        # create list of project classes
        projects = []
        for p in proj_dict:
            projects.append(Project(self,p))
        return projects

class Project(object):
    """
    Create Project instance.
    project must be tuple generated by RodosConnection 
    or project uid
    """
    def __repr__(self):
        return ("<Project %s | %s>" % (self.name, self.modelchainname))

    def __init__(self,rodos,values):
        """
        Project class is created based on project id fetch from REST service
        project_id is integer
        """
        self.rodos = rodos
        for key in values:
            setattr(self,key,values[key])

    def load(self):
        """Load project metadata"""
        # request project details from rest service
        response = urlopen( self.rodos.rest_url + "/projects/{:d}".format(
            self.projectId))
        details_dict = json.load(reader(response),
                                 object_hook=datetime_parser)
        # set metadata as attributes
        for key in details_dict:
            if (key not in ("tasks","extendedProjectInfo")):
                setattr(self,key,details_dict[key])
            elif key=="extendedProjectInfo":
                for key2 in details_dict[key]:
                    setattr(self,key2,details_dict[key][key2])
        # set source term nuclides as list
        self.sourcetermNuclides = self.sourcetermNuclides.split(",")
        for t in details_dict["tasks"]:
            self.tasks.append ( Task(self,t) )

class Task(object):
    """
    JRodos Task instance. Contains single model run.
    """
    def __repr__(self):
        return ("<Task %s | %s>" % (self.modelwrappername, self.description))

    def __init__(self,project,tdict):
        self.rodos = project.rodos
        self.project = project
        self.dataitems = []
        for key in tdict:
            if key!="dataitems":
                setattr(self,key,tdict[key])
        self.dataitems_json = tdict["dataitems"] # use this for searchs?
        self.gridseries = []
        for d in tdict["dataitems"]:
            if d["dataitem_type"]=="GridSeries":
                self.gridseries.append( GridSeries(self,d) )
        self.deposition = {}
        self.wet_deposition = {}
        self.dry_deposition = {}
        self.air_concentration = {}
        self.time_integrated_air_concentration = {}
        self.total_deposition = {}
        self.ground_gamma_dose_rate = {}
        self.total_dose = {}
        self.cloud_dose = {}
        self.ground_dose = {}
        self.inhalation_dose = {}
        self.skin_dose = {}
        
        # classify grid series to dictionaries
        # TODO: some items still missing (FDMT, Emersim, DEPOM etc.)
        for i in self.gridseries:
            try:
                i.nuclide = from_rodos_nuclide(i.name)
            except IndexError: # not nuclide dependent
                i.nuclide = None
            if i.groupname=="ground.contamination":
                self.deposition[i.nuclide] = i
            elif i.groupname=="ground.contamination.wet":
                self.wet_deposition[i.nuclide] = i
            elif i.groupname=="ground.contamination.dry":
                self.wet_deposition[i.nuclide] = i
            elif i.groupname=="air.concentration.near.ground.surface":
                self.air_concentration[i.nuclide] = i
            elif i.groupname==\
                "air.concentration.time.integrated.near.ground.surface":
                self.time_integrated_air_concentration[i.nuclide] = i
            elif i.groupname=="air.concentration.instantaneous.exceeded":
                self.concentration_exceeded = i
            elif i.groupname=="Graphical_Aerosol":
                self.total_deposition["aerosol"] = i
            elif i.groupname=="Graphical_Iodine":
                self.total_deposition["iodine"] = i
            elif i.groupname=="total.gamma.dose.rate":
                self.total_gamma_dose_rate = i
            elif i.groupname=="DOSRCL":
                self.cloud_total_gamma_dose_rate = i
            elif i.groupname=="DRNUGR":
                self.ground_gamma_dose_rate[i.nuclide] = i
            elif i.groupname=="total.dose":
                self.total_dose[i.name] = i
            elif i.groupname=="cloud.dose":
                self.cloud_dose[i.name] = i
            elif i.groupname=="ground.dose":
                self.ground_dose[i.name] = i
            elif i.groupname=="inhalation.dose":
                self.inhalation_dose[i.name] = i
            elif i.groupname=="skin.dose":
                self.skin_dose[i.name] = i
            elif i.groupname=="total.dose.nuclide.specific":
                self.total_dose[i.name] = i


class GridSeries(object):
    "Series of grid results"
    def __repr__(self):
        return ("<GridSeries %s | %s>" % (self.groupname, self.name))

    def __init__(self,task,ddict):
        self.task = task
        self.project = task.project
        self.rodos = task.rodos
        self.gpkgfile = None
        for key in ddict:
            setattr(self,key,ddict[key])
        self.output_dir = "{}/{}/{}/{}".format(self.rodos.storage,
                                               self.task.project.name,
                                               self.task.project.modelchainname,
                                               self.datapath.replace(" ","_"))

    def times(self):
        return ["TODO"]

    def levels(self):
        return ["TODO"]

    def get_filepath(self):
        "generate filepath if check if it does exists"
        if not os.path.isdir(self.output_dir):
            self.save_gpkg()
        return self.output_dir
    
    def gpkg_file(self):
        "get full path of gpkg file"
        return self.get_filepath() + "/" + os.listdir( self.get_filepath() )[0]

    def save_gpkg(self,output_dir=None,force=True):
        "Read and save GML file from WPS service"
        if output_dir==None:
            output_dir = self.output_dir
        wps_input = [
                ('taskArg', 
                 "project='{}'&amp;model='{}'".format(self.task.project.name,\
                                                      self.task.project.modelchainname)),
                ('dataitem',
                 "path='%s'" % self.datapath),
                ('columns', "0-"), # get the whole dataset
                ('vertical', "0"), # TODO: think!
                ('includeSLD', "1"),
                ('threshold', "1e-15") # TODO: add threshold support
            ]
        x = open("request_template.xml").read()
        x = x.replace("TASKARG",wps_input[0][1])
        x = x.replace("DATAITEM",wps_input[1][1])
        x = x.replace("COLUMNS",wps_input[2][1])
        x = x.replace("THRESHOLD",wps_input[5][1])
        #wps_run = self.rodos.wps.execute('gs:JRodosGeopkgWPS',wps_input)
        req = Request ( self.rodos.w["url"],
                        data = x.encode(), 
                        headers = xml_headers)
        logger.debug ( "Execute WPS with values %s" % (str(wps_input)) )
        response = urlopen( req )
        temp = tempfile.NamedTemporaryFile() #2
        try:
            resp_file = open(temp.name, "wb")
            resp_file.write( response.read() )
            resp_file.close()
            Path(output_dir).mkdir(parents=True, exist_ok=True)
            with zipfile.ZipFile(temp.name, 'r') as zip_ref:
                zip_ref.extractall(output_dir)
        finally:
            temp.close() 
        self.filepath = output_dir
        return self.filepath

    def max(self):
        "Get max value and its lon/lat location"
        gis_data = gpkg_driver.Open(self.gpkg_file())
        layer = gis_data.GetLayer(2) # view
        max_value = 0
        geom_wkt = None
        for feature in layer:
            value = feature.GetField("Value")
            if value>max_value:
                max_value = value
                geom_wkt = feature.GetGeometryRef().ExportToWkt()
        if geom_wkt!=None:
            transform = osr.CoordinateTransformation(layer.GetSpatialRef(),wgs84_cs)
            polygon = ogr.CreateGeometryFromWkt(geom_wkt)
            # use point instead of polygon
            point = polygon.PointOnSurface()
            lon,lat,dummy = transform.TransformPoint(point.GetX(),point.GetY())
        else:
            lon,lat = None, None
        return (max_value,(lon,lat))

#class Dataset(object):
#    """
#    JRodos dataset instance.
#    May contain several times and levels
#    """
#    def __repr__(self):
#        return ("<Task %s | %s>" % (self.task.name, self.path))
#
#    def __init__(self,task,values):
#        self.rodos = task.rodos
#        self.project = task.project
#        self.task = task
#        self.path = values["path"]
#        self.unit = values["unit"]
#        self.name = values["name"]
#        self.params = values["params"]
#        self.times = None
#        self.nuclides = None
#        self.levels = None
#        self.default_time = None
#        self.default_nuclide = None
#        if "date" in self.params:
#            self.get_times()
#        if "nuclide" in self.params:
#            self.get_nuclides()
#        if "level" in self.params:
#            self.get_levels()
#
#    def get_times(self):
#        "read timestamps as Python objects" 
#        for p in self.project.details["task"]:
#            if p["path"]==self.task.path:
#                for layer in p["layers"]:
#                    if layer["path"]==self.path:
#                        for f in layer["filters"]:
#                            if f["param"]=="date":
#                                times = f["allowedValues"]
#                            self.times = times
#                            self.default_time = f["defaultValue"]
#                            break
#        self.default_time = time_formatter(self.default_time)
#        self.times = list(map(time_formatter,self.times))
#
#    def get_nuclides(self):
#        "read nuclides"
#        for p in self.project.details["task"]:
#            if p["path"]==self.task.path:
#                for layer in p["layers"]:
#                    if layer["path"]==self.path:
#                        for f in layer["filters"]:
#                            if f["param"]=="nuclide":
#                                nuclides = f["allowedValues"]
#                                default = f["defaultValue"]
#        self.nuclides = list(map(from_rodos_nuclide,nuclides))
#        self.default_nuclide = from_rodos_nuclide(default)
#
#    def get_levels(self):
#        "read height values"
#        return ["TODO"]
# 
#class DataItem(object):
#    """ 
#    Single 2D dataset.
#    """
#    def __init__(self,dataset,t_index=0,nuclide=None,z_index=0):
#        self.dataset = dataset
#        self.rodos = dataset.rodos
#        self.t_index = t_index
#        self.z_index = z_index
#        self.nuclide = nuclide
#        self.wps_input = [
#            ('taskArg', 
#             "taskuid='%s'" % self.dataset.task.path),
#            ('dataitem',
#             "path='%s'" % self.dataset.path),
#            ('columns', str(t_index)), # only one column per data layer
#            ('vertical', str(z_index)),
#            ('threshold', str(0)) # TODO: add threshold support
#        ]
#        if nuclide:
#            # add nuclide to path parameter
#            self.wps_input[1] = (self.wps_input[1][0],
#                                 self.wps_input[1][1][:-1]\
#                                 + to_rodos_nuclide(nuclide) + "'")
#        self.gml = self.save_gml()
#        #read projection from gml
#        gml_data = open(self.gml).read()
#        t = "epsg.xml#"
#        ti = gml_data.find(t) + len(t)
#        p = "epsg:"
#        while gml_data[ti].isdigit():
#            p += gml_data[ti]
#            ti += 1
#        self.projection = p # human readable
#        # GDAL projection
#        self.srs = osr.SpatialReference()
#        try:
#            self.srs.ImportFromEPSG( int(p.split(":")[-1]) )
#        except ValueError:
#            # no features, no projection
#            self.srs = None
#        # coordinate transfrom operator
#        # store time value
#        if self.dataset.times:
#            self.timestamp = self.dataset.times[t_index]
#
#    def save_gml(self,filename=None,force=False):
#        if not filename:
#            if self.nuclide:
#                nuclide = self.nuclide
#            else:
#                nuclide = ""
#            filename = self.rodos.storage + "/%s_%s_%02d_%01d%s.gml" % \
#                (self.dataset.task.project.name,
#                 self.dataset.name.replace(" ","_"),
#                 self.t_index,
#                 self.z_index,
#                 nuclide)
#        if (os.path.exists(filename) and force==False):
#            return filename
#        wps_run = self.rodos.wps.execute('gs:JRodosWPS',self.wps_input)
#
#        logger.debug ( "Execute WPS with values %s" % (str(self.wps_input)) )
#        wps_run.getOutput ( filename )
#        return filename
#
#    def envelope(self):
#        gml_data = gml_driver.Open(self.gml)
#        layer = gml_data.GetLayer()
#        return layer.GetExtent()
#
#    def valueAtLonLat(self,lon,lat):
#        "read value at lon/lat point"
#        if self.srs==None: # no features
#            return None
#        transform = osr.CoordinateTransformation(wgs84_cs,self.srs)
#        x,y,dummy = transform.TransformPoint(lon,lat)
#        gml_data = gml_driver.Open(self.gml)
#        layer = gml_data.GetLayer()
#        wkt = "POINT (%f %f)" % (x,y)
#        layer.SetSpatialFilter(ogr.CreateGeometryFromWkt(wkt))
#        for feature in layer:
#            return float(feature.GetField("Value") )
#
#    def regrid(self,lonmin,latmin,lonmax,latmax,dx,dy,method="linear"):
#        "regrid data"
#        # TODO: not implemented!
#        if self.srs==None: # no features
#            return None
#        # generate polygon of lon/lat bbox to filter points
#        C = 10 # make sure every point in included
#        wkt_bbox = "POLYGON (( %f %f, %f %f, %f %f, %f %f, %f %f ))" %\
#            (lonmin-(C*dx), 
#             latmin-(C*dy), 
#             lonmin-(C*dx), 
#             latmax+(C*dy), 
#             lonmax+(C*dx), 
#             latmax+(C*dy), 
#             lonmin-(C*dx), 
#             latmax+(C*dy), 
#             lonmin-(C*dx), 
#             latmin-(C*dy))
#        transform = osr.CoordinateTransformation(wgs84_cs,self.srs)
#        polygon = ogr.CreateGeometryFromWkt( wkt_bbox )
#        polygon.Transform ( transform )
#        gml_data = gml_driver.Open(self.gml)
#        layer = gml_data.GetLayer()
#        points = []
#        values = []
#        transform2 = osr.CoordinateTransformation(self.srs,wgs84_cs)
#        for feature in layer:
#            geom = feature.GetGeometryRef()
#            if geom.Intersects( polygon ):
#                centroid = geom.Centroid()
#                centroid.Transform ( transform2 )
#                lon = centroid.GetX()
#                lat = centroid.GetY()
#                value = float(feature.GetField("Value"))
#                points.append( (lon,lat) )
#                values.append ( value )
#        return points,values
#
#    def valuesAtGeometry(self,wkt_geometry):
#        "read multiple values at lon/lat geometry"
#        if self.srs==None: # no features
#            return None
#        transform = osr.CoordinateTransformation(wgs84_cs,self.srs)
#        geom = ogr.CreateGeometryFromWkt( wkt_geometry )
#        geom.Transform ( transform )
#        gml_data = gml_driver.Open(self.gml)
#        layer = gml_data.GetLayer()
#        values = []
#        for feature in layer:
#            data_geom = feature.GetGeometryRef()
#            if data_geom.Intersects( geom ):
#                value = float(feature.GetField("Value"))
#                values.append ( value )
#        return values
#
#    def areaExceeding(self,value):
#        "calculate area where value is exceeded"
#        gml_data = gml_driver.Open(self.gml)
#        layer = gml_data.GetLayer()
#        layer.SetAttributeFilter( "Value > %f" % value )
#        area = 0
#        for feature in layer:
#            area += feature.GetGeometryRef().GetArea()
#        return area
#
#    def max(self):
#        "Get max value and its lon/lat location"
#        gml_data = gml_driver.Open(self.gml)
#        layer = gml_data.GetLayer()
#        max_value = 0
#        geom_wkt = None
#        for feature in layer:
#            value = feature.GetField("Value")
#            if value>max_value:
#                max_value = value
#                geom_wkt = feature.GetGeometryRef().ExportToWkt()
#        if geom_wkt!=None:
#            transform = osr.CoordinateTransformation(self.srs,wgs84_cs)
#            polygon = ogr.CreateGeometryFromWkt(geom_wkt)
#            # use point instead of polygon
#            point = polygon.PointOnSurface()
#            lon,lat,dummy = transform.TransformPoint(point.GetX(),point.GetY())
#        else:
#            lon,lat = None, None
#        return (max_value,(lon,lat))
