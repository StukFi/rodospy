# -*- coding: utf-8 -*-
from owslib.wps import WebProcessingService
import osr
import ogr
import os
from datetime import datetime, timedelta
from copy import copy
import psycopg2
# standard logging
import logging
logger = logging.getLogger('rodospy')
# set to INFO or WARNING in production environment
# set logging format
FORMAT = '%(asctime)-15s %(levelname)-6s %(message)s'
formatter = logging.Formatter(fmt=FORMAT)
# output to console
ch = logging.StreamHandler()
ch.setFormatter(formatter)
logger.addHandler(ch)

# GDAL contants
wgs84_cs = osr.SpatialReference()
wgs84_cs.ImportFromEPSG(4326)
gml_driver = ogr.GetDriverByName('GML')

class RodosPyException(Exception):
    "Module spesific exception"
    pass

class RodosConnection(object):
    """
    Setup JRodos database and Geoserver connection
    When initialized, connections are checked.
    The connection settings will be passed to other classes.
    """
    def __repr__(self):
        return ("<RodosConnection %s | %s>" % (self.pg, self.wps))

    def __init__(self,db_settings=None):
        "Initialize RODOS DB and WPS connection"
        logger.debug("Read settings from file")
        if db_settings==None:
            # try to read from config file
            raise RodosPyException( "No DB settings defined" )
        p = db_settings["postgres"]
        w = db_settings["wps"]
        self.pg = "host='%s' user='%s' password='%s' port=%i" % \
            (p["host"],p["user"],p["password"],p["port"])
        self.wps = WebProcessingService(w["url"], verbose=False, skip_caps=True)
        self.storage = w["file_storage"]
        # check that connections are OK
        self.check_connections()

    def query(self,query_string,dbname=None):
        """perform queries in JRodos Postgres database"""
        db_conn = self.pg 
        if dbname:
            db_conn += " dbname=%s" % dbname
        conn = psycopg2.connect(db_conn)
        cur = conn.cursor()
        logger.debug( "Execute Postgres query: %s" % query_string )
        cur.execute(query_string)
        rows = cur.fetchall()
        conn.close()
        return rows

    def check_connections(self):
        "Check connections"
        logger.debug("Check DB and WPS connections")
        # listing of projects?
        self.db_alive = False
        try:
            projects = self.projects()
            self.db_alive = True
        except RodosPyException: # db error?
            raise RodosPyException( "DB Connection failed" )
        # GetCapabilities
        try:
            capabilities = self.wps.getcapabilities()
            self.wps_alive = True
        except RodosPyException:
            raise RodosPyException( "WPS Service not available" )

    def projects(self,query_filter={}):
        "Get list of projects from RODOS DB"
        # get project list
        logger.debug ( "Get listing of projects from DB %s" % self.pg )
        q = "SELECT uid,name,description,username,modelchainname FROM project "
        if query_filter!={}:
            q += "WHERE "
            i = 0
            for key in query_filter.keys():
                if i>0:
                    q += " AND " 
                q += "%s='%s'" % (key,query_filter[key])
                i +=1
        result = self.query(q,"ModelEnvironment")
        projects = []
        for r in result:
            values = {
                "uid": r[0],
                "name": r[1],
                "description": r[2],
                "username": r[3],
                "modelchainname": r[4]
            }
            projects.append( Project(self, None, values) )
        return projects

class Project(object):
    """
    Create Project instance.
    project must be tuple generated by RodosConnection 
    or project uid
    """
    def __repr__(self):
        return ("<Project %s | %s>" % (self.name, self.modelchainname))

    def __init__(self,rodos,project_uid=None,values=None):
        "Project must be initialized with RODOS db connection"
        if (project_uid==None and values==None):
            raise RodosPyException( "Either project uid or velues dict must be defined" )
        self.rodos = rodos
        if project_uid:
            # query from database by project name
            q = "SELECT uid,name,description,username,modelchainname FROM project WHERE uid='%s';"\
                % (project_uid)
            result = self.rodos.query(q,"ModelEnvironment")[0]
        else:
            result = (
                values["uid"],
                values["name"],
                values["description"],
                values["username"],
                values["modelchainname"]
            )
        self.uid = result[0]
        self.name = result[1]
        self.description = result[2]
        self.username = result[3]
        self.modelchainname = result[4]

    def tasks(self):
        "Get tasks in the project"
        # read task id:s / names from db
        logger.debug( "Query project task list" )
        q = "SELECT uid,task_id,modelwrappername,description,projectuid, dataitem_id FROM task WHERE projectuid='%s'"\
            % self.uid
        result = self.rodos.query(q,"ModelEnvironment")
        tasks = []
        for r in result:
            values = {
                "task_uid": r[0],
                "task_id": r[1],
                "modelwrappername": r[2],
                "description": r[3],
                "project_uid": r[4],
                "dataitem_id": r[5]
            }
            tasks.append( Task( self.rodos,None, values ) )
        return tasks
 
class Task(object):
    """
    JRodos Task instance. Contains single model run.
    """
    def __repr__(self):
        return ("<Task %s | %s>" % (self.modelwrappername, self.description))

    def __init__(self,rodos,task_uid=None,values=None):
        self.rodos = rodos
        if (task_uid==None and values==None):
                raise RodosPyException( "Either task uid or velues dict must be defined" )
        if task_uid:
            q = "SELECT task_id, description, modelwrappername\
                , dataitem_id, projectuid,uid FROM task WHERE uid='%s'"\
                % (task_uid)
            result = self.rodos.query(q,"ModelEnvironment")[0]
        else:
            result = (
                values["task_id"],
                values["description"],
                values["modelwrappername"],
                values["dataitem_id"],
                values["project_uid"],
                values["task_uid"]
            )
        self.taskid = result[0]
        self.description = result[1]
        self.modelwrappername = result[2]
        self.dataitem_id = result[3]
        self.project = Project(rodos,result[4])
        self.task_uid = result[5]


    def datasets(self,filter_string=None):
        "list datasets available"
        # TODO: not working with Sqlite storage!
        # probably read from WPS service?
        logger.debug( "Get listing of Task datasets" )
        q = "SELECT dataitem_id,name,groupname,datapath FROM dataitem" # WHERE taskid=%i" % self.taskid
        # limit to prognostic results
        #q += " AND datapath LIKE '%Model data=;=Output=;=Prognostic Results=%' "
        if filter_string:
            q += " AND datapath LIKE '%" + filter_string + "%' "
        result = self.rodos.query(q,"ModelEnvironment")
        return result
        
class Dataset(object):
    """
    JRodos fataset instance.
    May contain several times and levels
    """
    def __repr__(self):
        return ("<Task %s | %s>" % (self.task.task_uid, self.path))

    def __init__(self,rodos,task,path):
        self.rodos = rodos
        self.task = task
        self.path = path

    def times(self):
        "read timestamps as Python objects" 
        return ["TODO"]
    
    def levels(self):
        "read height values"
        return ["TODO"]
 
class DataItem(object):
    def __init__(self,dataset,t_index=0,z_index=0):
        self.dataset = dataset
        self.rodos = dataset.rodos
        self.t_index = t_index
        self.z_index = z_index
        self.wps_input = [
            ('taskArg', 
             "taskuid='%s'" % self.dataset.task.task_uid),
            ('dataitem',
             "path='%s'" % self.dataset.path),
            ('column', str(t_index)),
            ('vertical', str(z_index))
        ]
        self.gml = self.save_gml()
        #read projection from gml
        gml_data = open(self.gml).read()
        t = "epsg.xml#"
        ti = gml_data.find(t) + len(t)
        p = "epsg:"
        while gml_data[ti].isdigit():
            p += gml_data[ti]
            ti += 1
        self.projection = p # human readable
        # GDAL projection
        self.srs = osr.SpatialReference()
        self.srs.ImportFromEPSG( int(p.split(":")[-1]) )
        # coordinate transfrom operator

    def save_gml(self,filename=None,force=False):
        if not filename:
           filename = self.rodos.storage + "/%s%s%i%i.gml" % \
                (self.dataset.task.task_uid,self.dataset.path,self.t_index,self.z_index)
        if (os.path.exists(filename) and force==False):
            return filename
        wps_run = self.rodos.wps.execute('gs:JRodosWPS',self.wps_input)
        logger.debug ( "Execute WPS with values %s" % (str(self.wps_input)) )
        wps_run.getOutput ( filename )
        return filename

    def valueAtLonLat(self,lon,lat):
        "read value at lon/lat point"
        transform = osr.CoordinateTransformation(wgs84_cs,self.srs)
        x,y,dummy = transform.TransformPoint(lon,lat)
        gml_data = gml_driver.Open(self.gml)
        layer = gml_data.GetLayer()
        wkt = "POINT (%f %f)" % (x,y)
        layer.SetSpatialFilter(ogr.CreateGeometryFromWkt(wkt))
        for feature in layer:
            return feature.GetField("Value") 

    def areaExceeding(self,value):
        "calculate area where value is exceeded"
        gml_data = gml_driver.Open(self.gml)
        layer = gml_data.GetLayer()
        layer.SetAttributeFilter( "Value > %f" % value )
        area = 0
        for feature in layer:
            area += feature.GetGeometryRef().GetArea()
        return area

    def max(self):
        "Get max value and its lon/lat location"
        gml_data = gml_driver.Open(self.gml)
        layer = gml_data.GetLayer()
        max_value = 0
        geom_wkt = None
        for feature in layer:
            value = feature.GetField("Value")
            if value>max_value:
                max_value = value
                geom_wkt = feature.GetGeometryRef().ExportToWkt()
        if geom_wkt!=None:
            transform = osr.CoordinateTransformation(self.srs,wgs84_cs)
            polygon = ogr.CreateGeometryFromWkt(geom_wkt)
            # use point instead of polygon
            point = polygon.PointOnSurface()
            lon,lat,dummy = transform.TransformPoint(point.GetX(),point.GetY())
        else:
            lon,lat = None, None
        return (max_value,(lon,lat))
        
